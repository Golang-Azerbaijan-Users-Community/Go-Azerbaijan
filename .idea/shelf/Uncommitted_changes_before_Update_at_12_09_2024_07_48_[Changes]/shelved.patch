Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Info\r\n\r\nBu repository Go dilini tez öyrənmək istəyənlər üçün hazırlanmışdır. Ümumilikdə mövzuları nümunələrlə izah edərək dilin əsas strukturlarını əhatə edir. Eyni zamanda, Go dilini öyrənmək istəyənlər üçün müntəzəm resurs təmin etmək məqsədi daşıyır. Hər bir mövzu təsviri və başa düşülən şəkildə əhatə olunur ki, oxucular Go dilini asanlıqla və tez öyrənə bilsinlər.\r\n\r\nRepository-ni bəyənirsinizsə, ulduz qoyub sosial media hesablarınızda paylaşa bilərsiniz ki, daha çox insana çatsın ⭐\uFE0F.\r\n\r\n## **Bu Go nədir?**\r\n\r\nGolang (digər adı Go) 2007-ci ildən Google tərəfindən hazırlanmış açıq mənbəli proqramlaşdırma dilidir. O, əsasən alt sistem proqramlaşdırması üçün nəzərdə tutulmuşdur və tərtib edilə bilən və statik olaraq yazılmış dildir. İlk versiya 2009-cu ilin noyabrında buraxıldı. Onun tərtibçisi \"gc\" (Go Compiler) bir çox əməliyyat sistemi üçün açıq mənbə kimi işlənib hazırlanmışdır.\r\n\r\nGolang ilk dəfə Google mühəndisləri Robert Griesemer, Rob Pike və Ken Thompson tərəfindən eksperimental məqsədlər üçün yaradılmışdır. Tənqid olunan problemlərin digər dillərdə həllini təmin etmək və onların yaxşı tərəflərini qorumaq üçün yaradılmışdır.\r\n\r\nGo sadə, sürətli və etibarlı proqram təminatı hazırlamaq üçün nəzərdə tutulmuş açıq mənbəli proqramlaşdırma dilidir. Go dili sürətli tərtib prosesi, yüngül sintaksis strukturu və effektiv garbage collection sistemi ilə seçilir.\r\n\r\nGo dilinin istifadəsinə müxtəlif inkişaf alətləri, paketlər və modullar daxildir. Tərtibatçılar Go dili ilə veb proqramlar, API-lər, verilənlər bazası sistemləri, şəbəkə proqram təminatı və sair kimi çoxlu müxtəlif növ proqramlar yarada bilərlər.\r\n\r\nGo dilinin əsas xüsusiyyətlərindən biri sürətli tərtib prosesidir. Go C dilinə bənzər sintaksis strukturundan və C++ kimi dillərdə obyekt yönümlü xüsusiyyətlərdən istifadə edir. Zibil toplama, yüngül iplər, kapsullaşdırılmış tip sistemlər və dinamik yaddaşın idarə edilməsi kimi xüsusiyyətlər də Go dilində mövcuddur.\r\n\r\nGo dilinin digər mühüm xüsusiyyəti onun effektiv paket idarəetmə sistemidir. Go dilində modullar və paketlər proqram tərtibatçılarına kodlarını nizamlı şəkildə təşkil etməyə və təkmilləşdirməyə imkan verir. Beləliklə, tərtibatçılar asanlıqla təkrar istifadə edilə bilən kodları yaza bilərlər.\r\n\r\nNəticədə, Go dilinin əsas xüsusiyyətlərinə sürətli tərtib prosesi, yüngül sintaksis strukturu, effektiv paket idarəetməsi, zibil toplama və kapsullaşdırılmış tip sistemlər kimi xüsusiyyətlər daxildir. Go-da inkişaf etdirmək bir çox proqram növləri üçün əlverişli seçimdir və proqram təminatının hazırlanması prosesini sürətləndirməyə kömək edə bilər.\r\n\r\n#### Məzmun:\r\n\r\n* [Values](./#values)\r\n* [Variables](./#variables)\r\n* [Constants](./#constants)\r\n* [If-Else](./#if-else)\r\n* [For](./#for)\r\n* [Switch](./#switch)\r\n* [Arrays](./#arrays)\r\n* [Slices](./#slices)\r\n* [Maps](./#maps)\r\n* [Range](./#range)\r\n* [Functions](./#functions)\r\n* [Variadic Functions](./#variadic-functions)\r\n* [Closures](./#closures)\r\n* [Recursion](./#recursion)\r\n* [Pointers](./#pointers)\r\n* [String Functions](./#strings-and-runes)\r\n* [Structs](./#structs)\r\n* [Methods](./#methods)\r\n* [Interfaces](./#interfaces)\r\n* [Struct Embedding](./#struct-embedding)\r\n* [Errors](./#errors)\r\n* [Goroutines](./#goroutines)\r\n* [Channel](./#channel)\r\n* [Select](./#select)\r\n* [Timeouts](./#timeouts)\r\n* [Non-Blocking Channel](README%20\\(1\\).md#non-blocking-channel)\r\n* [Closing Channels](./#closing-channels)\r\n* [Range over Channels](./#range-over-channels)\r\n* [Timers](./#timers)\r\n* [Tickers](./#ticker)\r\n* [Worker Pools](./#worker-pools)\r\n* [Wait Groups](./#waitgroups)\r\n* [Rate Limiting](./#ratelimiting)\r\n* [Atomic Counters](README%20\\(1\\).md#atomic-counters)\r\n* [Sorting](README%20\\(1\\).md#sorting)\r\n* [Panic](README%20\\(1\\).md#panic)\r\n* [Defer](README%20\\(1\\).md#defer)\r\n* [Recover](README%20\\(1\\).md#recover)\r\n* [Strings and Runes](README%20\\(1\\).md#strings-and-runes)\r\n* [Text Templates](README%20\\(1\\).md#text-templates)\r\n* [JSON](README%20\\(1\\).md#json)\r\n\r\n***\r\n\r\n## Values\r\n\r\nDəyərlər Go proqramlaşdırma dilində dəyişənlər tərəfindən daşınan məlumatlardır. Dəyərlər sabit və ya dəyişən ola bilər və müxtəlif məlumat növlərini təmsil edir.\r\n\r\nGo dilində əsas məlumat növləri bunlardır:\r\n\r\n* Ədədi məlumat növləri: Ədədi dəyərləri ifadə etmək üçün int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr, float32, float64, complex64, complex128, byte, rune kimi məlumat növlərindən istifadə olunur.\r\n* Boolean məlumat növü: bool məlumat növü yalnız doğru və ya yanlış qiymətlər qəbul edə bilən məlumat növüdür.\r\n* String data type: string data type mətn və ya simvol sətirinin qiymətlərini ifadə etmək üçün istifadə olunur.\r\n* Mürəkkəb məlumat növləri: struct, array, slice, map, channel kimi məlumat tipləri çoxsaylı məlumat elementlərini bir yerdə saxlamaq və müəyyən bir məqsədə xidmət etmək üçün istifadə olunur.\r\n\r\nDəyərlərin növləri Go dilində statik olaraq müəyyən edilir. Dəyişənə qiymət təyin etdikdə bu dəyişənin tipi müəyyən edilir və biz bu tipi sonra dəyişə bilmərik.\r\n\r\n```go\r\nvar age int\r\nage = 32\r\n\r\nage = \"thirty-two\" // compile error: cannot use \"thirty-two\" (type string) as type int in assignment\r\n```\r\n\r\nBu nümunədə yaş dəyişəni ilk olaraq int kimi elan edilir və sonra dəyişən yaş üçün 32 rəqəmi təyin edilir. Sonra \"thirty-two\" sətri yaş dəyişəninə təyin edilməyə çalışılır və proqram xəta verir. Yaş dəyişəni int növü kimi təyin olunduğu üçün ona sətir tipli qiymət təyin edilə bilməz. Dəyərlər proqramları müxtəlif məqsədlər üçün istifadə etməyə imkan verir. Məsələn, rəqəmsal əməliyyatı yerinə yetirmək üçün int dəyərindən istifadə edə bilərik və ya mətn əməliyyatını yerinə yetirmək üçün string dəyərindən istifadə edə bilərik.\r\n\r\n***\r\n\r\n## Variables\r\n\r\nDəyişənlər Go proqramlaşdırma dilində məlumatların saxlanması üçün istifadə olunan əsaslardan biridir. Dəyişənə qiymət təyin etməklə biz proqramda həmin dəyişənin saxladığı qiymətdən istifadə edə bilərik.\r\n\r\nDəyişənlərin elan edilməsi var açar sözü ilə həyata keçirilir. Müəyyən ediləcək dəyişənin adı və məlumat tipi müəyyən edilir. Heç bir ilkin dəyər verilmədikdə, Go dilində dəyişənlər standart dəyərə malikdirlər.\r\n\r\n```go\r\nvar name string\r\nname = \"John Doe\"\r\n```\r\n\r\nBu nümunədə ad adlı dəyişən müəyyən edilir və bu dəyişənin tipi sətir kimi müəyyən edilir. Sonra, ad dəyişəninə \"John Doe\" sətri təyin edilir. Dəyişənlərin dəyəri dəyişdirilə bilər və onlar müxtəlif məlumat tiplərində ola bilər.\r\n\r\n```go\r\nvar age int\r\nage = 32\r\n\r\nage = \"thirty-two\" // compile error: cannot use \"thirty-two\" (type string) as type int in assignment\r\n```\r\n\r\nBu misalda əvvəlcə yaş adlı dəyişən müəyyən edilir və bu dəyişənin növü int kimi müəyyən edilir. Sonra, dəyişən yaşa 32 nömrəsi verilir.\r\n\r\nDaha sonra yaş dəyişəninə \"thirty-two\" sətri təyin edilməyə çalışılır və proqram xəta verir. Yaş dəyişəni int növü kimi təyin olunduğu üçün ona sətir tipi dəyəri təyin edilə bilməz.\r\n\r\nDəyişənlər proqramlarda müəyyən bir məqsədə xidmət etmək üçün istifadə olunur. Məsələn, istifadəçinin adı, yaşı və ya bir sıra ədədi dəyərlər saxlanıla bilər.\r\n\r\n## Constants\r\n\r\nSabitlər (constants) Go proqramlaşdırma dilində proqramın heç bir yerində dəyişdirilə bilməyən sabit dəyərlərdir. Sabitlər bir dəfə müəyyən edilir və sonra proqramın istənilən yerində istifadə edilə bilər.\r\n\r\nSabitlər const açar sözü ilə müəyyən edilir və onların məlumat növləri göstərilir. Sabitlər işə salınmalıdır və sonra dəyişdirilə bilməz.\r\n\r\n```go\r\nconst pi = 3.14159\r\nconst welcomeMessage = \"Welcome to Go programming\"\r\n```\r\n\r\nBu nümunədə, sabit pi float64 növü kimi müəyyən edilir və 3.14159-a mənimsədilir. Sonra, welcomeMessage sabiti sətir kimi müəyyən edilir və \"Welcome to Go programming\" olaraq işə salınır.\r\n\r\nSabitlər müəyyən bir məqsəd üçün istifadə ediləcək proqramların sabit dəyərlərini saxlamaq üçün istifadə olunur. Məsələn, pi sayı və ya xüsusi mesaj və ya səhv kodu. Sabitlər proqramları daha oxunaqlı və davamlı etməyə kömək edir və proqramın müxtəlif yerlərində eyni sabitdən dəfələrlə istifadə etməyi asanlaşdırır.\r\n\r\nSabitlər proqramın istənilən yerində istifadə oluna bildiyi üçün onlar müxtəlif fayllar arasında da paylaşıla bilər. Bundan əlavə, sabitlərin dəyişdirilə bilməməsi proqram səhvlərini azaldır və təhlükəsizliyi artırır.\r\n\r\n## if/else\r\n\r\nif və else ifadələri, Go programlaşdırma dilində, müəyyən şərtlərin doğru və ya yanlış olduğu hallarda fərqli kod bloklarının işləməsini həyata keçirir.\r\n\r\n```go\r\nif x > 0 {\r\n    fmt.Println(\"Positive number\")\r\n} else if x < 0 {\r\n    fmt.Println(\"Negative number\")\r\n} else {\r\n    fmt.Println(\"Zero\")\r\n}\r\n```\r\n\r\nBu nümunədə, if ifadəsi, x dəyişkənin 0 dan böyük olması halında \"Positive number\" mətnini yazdıracaq. Əgər x dəyişəni 0 dan böyük deyilsə, else if ifadəsi yoxlanılacaq ve x dəyişəninin 0 dan kiçik olması halında \"Negative number\" mətnini yazdıracaq. Əgər x dəyişəni 0 dan böyük və ya kiçik deyilsə, else bloku işləyəcək ve \"Zero\" mətnini yazdıracaqdır.\r\n\r\n```go\r\nif və else ifadələri, qarışıq şərtləri idarə etmək üçün də istifadə oluna bilər.\r\nif x > 10 && x < 20 {\r\n    fmt.Println(\"x is between 10 and 20\")\r\n} else if x > 20 && x < 30 {\r\n    fmt.Println(\"x is between 20 and 30\")\r\n} else {\r\n    fmt.Println(\"x is not between 10 and 30\")\r\n}\r\n```\r\n\r\nBu nümunədə, if ifadəsi, x dəyişənin 10 ve 20 arasında olması halında \"x is between 10 and 20\" mətnini yazdıracaqdır. Əgər x dəyişəni 10 ve 20 arasında deyilsə, else if ifadesi yoxlanılacaq və x dəyişənin 20 və 30 arasında olması halında \"x is between 20 and 30\" mətnini yazdıracaqdır. Əgər x dəyişəni 10 və 30 arasında deyilsə, else bloku işələyəcəkdir və \"x is not between 10 and 30\" mətnini yazdıracaqdır.\r\n\r\n## For\r\n\r\nfor dövür operatırı, Go programlasdırma dilində, müəyyən bir şərt doğru olduğu halda təkrarlanan kod bloklarını ifadə etmək üçün istifadə olunur. for dövrü, bir başlanğıc halı, bir şərt və bir addım dəyərinə sahibdir.\r\n\r\n```go\r\nfor i := 0; i < 5; i++ {\r\n    fmt.Println(i)\r\n}\r\n```\r\n\r\nBu nümunədə, for dövrü, i dəyişəninin 0 dəyərindən başlayaraq, i dəyişəni < 5 şərtini ödədiyi müddətcə təkrarlanan bir dövrdür. Dövrdəki hər adımdda i dəyişəni 1 artırılır və nəticədə i dəyəri 4 olur.\r\n\r\nfor dövrü, şərt hissəsi doğru olana qədər təkrarlanır. Şərt hissəsi doğru olmadığında, dövr sonlanır. Ayrıca, for dövrü break və ya continue ifadələri ilə də idarə edilə bilir.\r\n\r\n```go\r\nfor i := 0; i < 10; i++ {\r\n    if i == 3 {\r\n        break\r\n    }\r\n    if i%2 == 0 {\r\n        continue\r\n    }\r\n    fmt.Println(i)\r\n}\r\n```\r\n\r\nBu nümunədə, for dövrü, i dəyişəninin 0 dəyərindən başlayaraq, i dəyişəni < 10 şərtini ödəyənədək təkrarlanan bir dövrdür. Dövrdəki hər adımdda, i dəyişəni 1 artırılır.\r\n\r\nDövr, if şərti ilə kəsilir ve break ifadesi işə düşür. Ayrıca, i dəyəri 3 olduğunda da dövr sonlanır.\r\n\r\nDövr içindəki digər if şərti isə, əgər i dəyəri cüt ədəddirsə bir sonrakı addıma keçərək i dəyərini yazdırmaz. Bu şərtin səbəbi, sadəcə tək ədədləri yazdırmaq istəməmizdir.\r\n\r\nSonsuz dövr yaratmaq üçün aşağıdakı nümunəyə baxaq.\r\n\r\n```go\r\ni:=0\r\nfor  {\r\n    if i == 100 {\r\n        break\r\n    }\r\n    fmt.Println(i)\r\n\t\r\n\ti++\r\n}\r\n```\r\n\r\nBu nümunədə i dəyişənimizə 0 dəyərini mənimsədirik. Daha sonra dövr daxilində i əgər 100-ə bərabər olarsa break ifadəsi ilə dövrü sonlandırırıq, əks halda dövr davam edəcəkdir\r\n\r\n## Switch\r\n\r\nSwitch ifadəsi müəyyən şərtlər əsasında müxtəlif əməliyyatları yerinə yetirmək üçün Go proqramlaşdırma dilində istifadə olunur:\r\n\r\n```go\r\nday := \"sunday\"\r\n\r\nswitch day {\r\ncase \"monday\":\r\n    fmt.Println(\"Today is Monday\")\r\ncase \"tuesday\":\r\n    fmt.Println(\"Today is Tuesday\")\r\ncase \"wednesday\":\r\n    fmt.Println(\"Today is Wednesday\")\r\ncase \"thursday\":\r\n    fmt.Println(\"Today is Thursday\")\r\ncase \"friday\":\r\n    fmt.Println(\"Today is Friday\")\r\ncase \"saturday\":\r\n    fmt.Println(\"Today is Saturday\")\r\ncase \"sunday\":\r\n    fmt.Println(\"Today is Sunday\")\r\ndefault:\r\n    fmt.Println(\"Invalid day\")\r\n}\r\n```\r\n\r\nBu misalda switch ifadəsi gün dəyişəninin dəyərindən asılı olaraq müxtəlif əməliyyatlar yerinə yetirir. Gün dəyişəni \"monday\"dirsə, \"Today is Monday\" mətnini çap edir. Gün dəyişəni \"tuesday\"dırsa, \"Today is Tuesday\" mətnini çap edir. Bu şəkildə, gün dəyişəninin dəyərindən asılı olaraq müxtəlif kod blokları icra edilə bilər.\r\n\r\ndefault ifadəsi bütün şərtlər doğru olmadığı təqdirdə işləyəcək kod blokuna aiddir.\r\n\r\n```go\r\nswitch x {\r\ncase 1:\r\n    fmt.Println(\"x is 1\")\r\ncase 2:\r\n    fmt.Println(\"x is 2\")\r\ncase 3:\r\n    fmt.Println(\"x is 3\")\r\ndefault:\r\n    fmt.Println(\"x is not 1, 2 or 3\")\r\n}\r\n```\r\n\r\nBu misalda switch ifadəsi x dəyişəninin qiymətindən asılı olaraq müxtəlif əməliyyatlar yerinə yetirir. Əgər x dəyişəni 1-dirsə, o, \"x-1-dir\" mətnini çap edir. Əgər x dəyişəni 2-dirsə, o, \"x-2-dir\" mətnini çap edir. Əgər x dəyişəni 3-dürsə, o, “x-3-dür” mətnini çap edir. Əgər x dəyişəni 1, 2 və ya 3 deyilsə, standart blok işləyəcək və \"x is not 1, 2 or 3\" mətnini çap edəcək.\r\n\r\n## Arrays\r\n\r\nArray , Go proqramlaşdırma dilində eyni tipdə bir neçə dəyişəni tək bir dəyişkəndə saxlamağa imkan verən bir məlumat strukturudur. Bir array əvvəlcədən müəyyən edilmiş ölçüyə və müəyyən bir məlumat tipinə malikdir.\r\n\r\n```go\r\nvar a [5]int\r\na[0] = 1\r\na[1] = 2\r\na[2] = 3\r\na[3] = 4\r\na[4] = 5\r\nfmt.Println(a)\r\n```\r\n\r\nBu nümunədə, a adlı bir array müəyyən edilir və ölçüsü 5 olaraq təyin edilir. Array-in elementlərinə a\\[index] sintaksisi ilə daxil olmaq olar və elementlər tək-tək təyin edilə bilər. Bu nümunədə, array elementlərinə müvafiq olaraq 1, 2, 3, 4 və 5 dəyərləri təyin edilir və fmt.Println(a) ifadəsi istifadə edilərək bütün array-in elementləri ekrana çıxarılır.\r\n\r\nArray-lərin ölçüsü bir dəfə təyin edildikdən sonra dəyişdirilə bilməz. Ancaq Go dilindəki dil xüsusiyyətləri ilə array ölçüləri dəyişdirilə bilər. Bu xüsusiyyət, Go dilində slice adlanan bir məlumat strukturu ilə həyata keçirilir.\r\n\r\n```go\r\na := [5]int{1, 2, 3, 4, 5}\r\nfmt.Println(a)\r\n```\r\n\r\nBu nümunədə, a adlı bir array müəyyən edilir və elementləri {1, 2, 3, 4, 5} olaraq təyin edilir. Array-in ölçüsü elementlərin sayına bərabər olmalıdır. Bu nümunədə, a adlı array {1, 2, 3, 4, 5} dəyərləri ilə başlatılır və bütün elementləri ekrana çıxarılır.\r\n\r\n## Slices\r\n\r\nDilimin əsas məlumat strukturlarından biri olan slices, Go proqramlaşdırma dilində ölçüsü dəyişdirilə bilən, elastik bir array məlumat strukturdur. Slices, array-lərin bir alt hissəsi kimi qəbul edilə bilər və Go dilində tez-tez istifadə olunur.\r\n\r\n```go\r\na := []int{1, 2, 3, 4, 5}\r\nfmt.Println(a)\r\n```\r\n\r\nBu nümunədə, a adlı bir dilim təyin edilir və elementləri {1, 2, 3, 4, 5} olaraq təyin edilir. Array-lərdən fərqli olaraq, dilimlərin ölçüsü təyin edilmə mərhələsində göstərilmir. Slices boş da təyin edilə bilər.\r\n\r\n```go\r\nvar a []int\r\na = append(a, 1)\r\na = append(a, 2, 3, 4, 5)\r\nfmt.Println(a)\r\n```\r\n\r\nBu nümunədə, a adlı bir dilim təyin edilir və append() funksiyası ilə elementlərinə müvafiq olaraq 1, 2, 3, 4 və 5 dəyərləri əlavə edilir. append() funksiyası, bir dilimə bir və ya bir neçə element əlavə etmək üçün istifadə olunur.\r\n\r\nDilimlər, array-lərdən fərqli olaraq, bir alt hissə kimi də təyin edilə bilər.\r\n\r\n```go\r\na := []int{1, 2, 3, 4, 5}\r\nb := a[1:4]\r\nfmt.Println(b)\r\n```\r\n\r\nBu nümunədə, a adlı bir dilim təyin edilir və elementlərinə {1, 2, 3, 4, 5} dəyərləri verilir. b adlı bir dilim isə a diliminin 1-ci indeksindən 4-cü indeksinə qədər olan alt hissəsini əhatə edir. b dilimindəki elementlər {2, 3, 4} olaraq göstərilir.\r\n\r\n## Maps\r\n\r\nMap, Go proqramlaşdırma dilində bir açar-dəyər cütləri kolleksiyasıdır. Map məlumat strukturu, digər proqramlaşdırma dillərindəki dictionary, hash table və ya associative array kimi məlumat strukturlarına bənzəyir. Bir Map məlumat strukturu, müəyyən bir açar üçün bir dəyər saxlayır.\r\n\r\n```go\r\nvar colors map[string]string\r\ncolors = make(map[string]string)\r\ncolors[\"red\"] = \"#FF0000\"\r\ncolors[\"green\"] = \"#00FF00\"\r\ncolors[\"blue\"] = \"#0000FF\"\r\nfmt.Println(colors)\r\n```\r\n\r\nBu nümunədə, colors adlı bir Map təyin edilir və make() funksiyası ilə yaradılır. colors məlumat strukturu red, green və blue açarlarına sahib rəng kodları ilə doldurulur və fmt.Println(colors) ifadəsi istifadə edilərək Map məlumat strukturundakı bütün açar-dəyər cütləri ekrana çıxarılır.\r\n\r\nMap məlumat strukturu, digər proqramlaşdırma dillərindəki məlumat strukturlarından fərqli olaraq, açarlar və dəyərlər üçün müəyyən bir məlumat tipini göstərmək məcburiyyətində deyil. Açarlar və dəyərlər fərqli məlumat tiplərində ola bilər.\r\n\r\n```go\r\nages := map[string]int{\r\n    \"Alice\": 25,\r\n    \"Bob\":   30,\r\n    \"Carol\": 35,\r\n}\r\nfmt.Println(ages)\r\n```\r\n\r\nBu nümunədə, ages adlı bir Map təyin edilir və string tipində açarlar və int tipində dəyərlərlə əlaqəli cütlər təyin olunur. Map məlumat strukturunun yaradılması və elementlərin əlavə edilməsi make() funksiyası ilə birləşdirilərək də həyata keçirilə bilər.\r\n\r\n## Range\r\n\r\nrange ifadəsi, Go proqramlaşdırma dilində müəyyən bir array, dilim və ya map üzərində dövr yaratmaq üçün istifadə olunur. range ifadəsi, məlumat strukturundakı bütün elementləri tək-tək götürmək üçün istifadə olunur.\r\n\r\n```go\r\nnumbers := []int{1, 2, 3, 4, 5}\r\nfor i, num := range numbers {\r\n    fmt.Println(\"index:\", i, \"number:\", num)\r\n}\r\n```\r\n\r\nBu nümunədə, numbers adlı bir dilim təyin edilir və elementlərinə {1, 2, 3, 4, 5} dəyərləri verilir. range ifadəsi istifadə edilərək, numbers dilimindəki bütün elementlər tək-tək götürülür və for dövrü içində istifadə olunur. i dəyişəni dövrün sırasındakı indeks dəyərini, num dəyişəni isə indeksdəki elementi təmsil edir. Bu nümunədə, indekslər və elementlər birgə yazdırılır.\r\n\r\n```go\r\ncolors := map[string]string{\r\n    \"red\":   \"#FF0000\",\r\n    \"green\": \"#00FF00\",\r\n    \"blue\":  \"#0000FF\",\r\n}\r\nfor color, code := range colors {\r\n    fmt.Println(\"color:\", color, \"code:\", code)\r\n}\r\n```\r\n\r\nBu nümunədə, colors adlı bir map təyin edilir və red, green və blue açarlarına sahib rəng kodları verilir. range ifadəsi istifadə edilərək, colors xəritəsindəki bütün açar-dəyər cütləri tək-tək götürülür və for dövrü içində istifadə olunur. color dəyişəni açarı, code dəyişəni isə açara uyğun dəyəri təmsil edir. Bu nümunədə, rənglər və onların kodları birgə yazdırılır.\r\n\r\n## Functions\r\n\r\nFunksiya, Go proqramlaşdırma dilində, müəyyən bir vəzifəni yerinə yetirən kod bloklarını ifadə edir. Bir funksiya, bir və ya bir neçə parametr ala bilər, bir əməliyyatı həyata keçirə bilər və bir və ya bir neçə nəticə qaytara bilər.\r\n\r\n```go\r\nfunc add(a int, b int) int {\r\nreturn a + b\r\n}\r\n\r\nresult := add(5, 10)\r\nfmt.Println(result)\r\n```\r\n\r\nBu nümunədə, add adlı bir funksiya təyin edilir. Funksiya, a və b adlı iki int tipində parametr qəbul edir və bu parametrlər toplanaraq nəticə int tipində geri qaytarılır. add funksiyası, 5 və 10 parametrləri ilə çağırılır və nəticə fmt.Println(result) ifadəsi ilə yazdırılır.\r\n\r\n```go\r\nfunc swap(a, b string) (string, string) {\r\n    return b, a\r\n}\r\n\r\nx, y := swap(\"hello\", \"world\")\r\nfmt.Println(x, y)\r\n```\r\n\r\nBu nümunədə, swap adlı bir funksiya təyin edilir. Funksiya, a və b adlı iki string tipində parametr qəbul edir və bu parametrləri bir-biri ilə dəyişdirərək geri qaytarır. swap funksiyası, \"hello\" və \"world\" parametrləri ilə çağırılır və geri qaytarılan nəticələr x və y dəyişənləri tərəfindən qəbul edilir. Nəticələr fmt.Println(x, y) ifadəsi ilə yazdırılır.\r\n\r\n## Variadic Functions\r\n\r\nVariadic funksiyalar, Go proqramlaşdırma dilində dəyişən sayda arqument qəbul edən funksiyalardır. Bu funksiyalar bir və ya daha çox arqument qəbul edə bilər və arqumentlərin sayını dəyişən olaraq təyin etməyə imkan verir.\r\n\r\n```go\r\nfunc sum(nums ...int) int {\r\n    total := 0\r\n    for _, num := range nums {\r\n        total += num\r\n    }\r\n    return total\r\n}\r\n\r\nfmt.Println(sum(1, 2, 3, 4, 5))\r\nfmt.Println(sum(2, 4, 6))\r\n```\r\n\r\nBu nümunədə, sum adlı bir funksiya təyin edilir. Funksiya, nums adlı int tipində dəyişən sayda parametr qəbul edir və onların cəmini qaytarır. Funksiyanın daxilində for dövrü istifadə edərək, nums dilimindəki bütün elementlərin cəmi hesablanır. Funksiya sum(1, 2, 3, 4, 5) və sum(2, 4, 6) şəklində çağırılır və nəticələr ekrana yazdırılır.\r\n\r\n```go\r\nfunc concatenate(sep string, strs ...string) string {\r\n    result := \"\"\r\n    for i, str := range strs {\r\n        if i > 0 {\r\n            result += sep\r\n        }\r\n        result += str\r\n    }\r\n    return result\r\n}\r\n\r\nfmt.Println(concatenate(\", \", \"foo\", \"bar\", \"baz\"))\r\nfmt.Println(concatenate(\"-\", \"hello\", \"world\"))\r\n```\r\n\r\nBu nümunədə, concatenate adlı bir funksiya təyin edilir. Funksiya, sep adlı string tipində bir parametr və strs adlı dəyişən sayda string tipində parametrlər qəbul edir. Funksiyanın daxilində for dövrü istifadə edilərək, strs dilimindəki bütün elementlər birləşdirilir və sep ayracı ilə birgə yazılır. Funksiya concatenate(\", \", \"foo\", \"bar\", \"baz\") və concatenate(\"-\", \"hello\", \"world\") şəklində çağırılır və nəticələr ekrana yazdırılır.\r\n\r\n## Closures\r\n\r\nClosures, Go proqramlaşdırma dilində, bir funksiyanın başqa bir funksiyanın daxilində yaradılması ilə əmələ gələn bir strukturdur. Bu struktur, bir funksiyanın daxilində olan başqa bir funksiyaya istinad edərək, funksiyanın işlədiyi mühitin xaricindəki dəyişənlərə giriş imkanı verir.\r\n\r\n```go\r\nfunc outer() func() int {\r\n    count := 0\r\n    return func() int {\r\n        count++\r\n        return count\r\n    }\r\n}\r\n\r\nincrement := outer()\r\nfmt.Println(increment())\r\nfmt.Println(increment())\r\nfmt.Println(increment())\r\n```\r\n\r\nBu örnekte, outer adlı bir fonksiyon tanımlanır. Fonksiyon, bir iç fonksiyon döndürür ve iç fonksiyon, count adlı bir değişkene erişim sağlar. increment adlı bir değişkene outer() fonksiyonu atanır ve bu değişken ile iç fonksiyon çalıştırılır. count değişkeni, increment() çağrıldıkça artar ve her seferinde artışı ekrana yazdırılır.\r\n\r\n```go\r\nfunc adder(a int) func(int) int {\r\n    return func(b int) int {\r\n        return a + b\r\n    }\r\n}\r\n\r\naddFive := adder(5)\r\nfmt.Println(addFive(2))\r\nfmt.Println(addFive(3))\r\n```\r\n\r\nBu nümunədə, adder adlı bir funksiya təyin edilir. Funksiya, a adlı bir int tipində parametr qəbul edir və bir daxili funksiya qaytarır. Daxili funksiya, b adlı bir int tipində parametr qəbul edir və a ilə b parametrlərinin cəmini geri qaytarır. addFive adlı bir dəyişənə adder(5) funksiyası təyin edilir və bu dəyişən ilə daxili funksiya işlədilir. addFive(2) və addFive(3) çağırıldıqca nəticələr ekrana yazdırılır.\r\n\r\n## Recursion\r\n\r\nRecursion, Go proqramlaşdırma dilində, bir funksiyanın özünü çağırmasıdır. Bu struktur, müəyyən bir şərt yerinə yetirilənə qədər funksiyanın təkrarlanaraq işləməsini təmin edir.\r\n\r\n```go\r\nfunc factorial(n int) int {\r\n    if n == 0 {\r\n        return 1\r\n    }\r\n    return n * factorial(n-1)\r\n}\r\n\r\nfmt.Println(factorial(5))\r\n```\r\n\r\nBu nümunədə, factorial adlı bir funksiya təyin edilir. Funksiya, n adlı bir int tipində parametr qəbul edir və faktorialı hesablayır. Funksiya daxilində, if şərti istifadə edilərək n dəyərinin 0 olub-olmadığı yoxlanılır. Əgər n 0-dırsa, 1 qaytarılır. Əgər n 0 deyil, başqa bir dəyərdirsə, funksiya özünü yenidən çağıraraq faktorialı hesablayır. factorial(5) çağırıldıqda nəticə ekrana yazdırılır.\r\n\r\n```go\r\nfunc fibonacci(n int) int {\r\n    if n < 2 {\r\n        return n\r\n    }\r\n    return fibonacci(n-1) + fibonacci(n-2)\r\n}\r\n\r\nfmt.Println(fibonacci(10))\r\n```\r\n\r\nBu nümunədə, fibonacci adlı bir funksiya təyin edilir. Funksiya, n adlı bir int tipində parametr qəbul edir və Fibonacci sayını hesablayır. Funksiya daxilində, if şərti istifadə edilərək n dəyərinin 2-dən kiçik olub-olmadığı yoxlanılır. Əgər n 2-dən kiçikdirsə, n dəyəri geri qaytarılır. Əks halda, funksiya özünü yenidən çağıraraq Fibonacci sayını hesablayır. fibonacci(10) çağırıldıqda nəticələr ekrana yazdırılır.\r\n\r\n## Pointers\r\n\r\nPointers, Go proqramlaşdırma dilində, bir dəyişənin yaddaş ünvanını saxlayan bir məlumat tipidir. Yaddaş ünvanı, dəyişənin yaddaşda yerləşdiyi yerdir.\r\n\r\n```go\r\nfunc zeroVal(val int) {\r\n    val = 0\r\n}\r\n\r\nfunc zeroPtr(ptr *int) {\r\n    *ptr = 0\r\n}\r\n\r\nx := 5\r\nzeroVal(x)\r\nfmt.Println(x)\r\n\r\ny := 5\r\nzeroPtr(&y)\r\nfmt.Println(y)\r\n```\r\n\r\nBu nümunədə, zeroVal adlı bir funksiya təyin edilir. Funksiya int tipində bir parametr qəbul edir və val dəyişəninin dəyərini 0 olaraq dəyişir, amma bu dəyişiklik orijinal dəyişənə təsir etmir. Digər tərəfdən, zeroPtr adlı bir funksiya isə bir pointer (\\*int) qəbul edir və bu göstərici ilə göstərilən dəyişənin dəyərini 0 olaraq dəyişdirir. x dəyişəninə 5 dəyəri atanır və zeroVal(x) çağırılır, amma x dəyişməz. y dəyişəninə isə 5 dəyəri atanır və zeroPtr(\\&y) çağırıldıqda, y 0 olur.\r\n\r\n```go\r\nfunc swap(a, b *int) {\r\n    temp := *a\r\n    *a = *b\r\n    *b = temp\r\n}\r\n\r\nx := 5\r\ny := 10\r\nswap(&x, &y)\r\nfmt.Println(x, y)\r\n```\r\n\r\nBu nümunədə, swap adlı funksiya iki pointer (\\*int) qəbul edir və həmin dəyişənlərin dəyərlərini bir-biri ilə dəyişir. x-ə 5 və y-ə 10 dəyəri verilir. swap(\\&x, \\&y) çağırıldıqdan sonra, x 10 olur, y isə 5 olur.\r\n\r\n## Strings and Runes\r\n\r\nStrings, Go proqramlaşdırma dilində, Unicode simvollarının birləşdirilməsi ilə yaradılan bir simvol sətiridir. Hər bir simvol 1-4 byte arasında dəyişən ölçülərdə ola bilər.\r\n\r\n```go\r\nstr := \"hello\"\r\nfmt.Println(str)\r\nfmt.Println(str[0])\r\nfmt.Println(str[1:3])\r\n```\r\n\r\nBu nümunədə, str adlı bir string dəyişəni təyin edilir və \"hello\" dəyəri verilir. str dəyişəni ekrana çap olunur, sonra isə str\\[0] ifadəsi istifadə edilərək sətirin ilk simvolu olan \"h\" ekrana çap edilir. str\\[1:3] ifadəsi istifadə edilərək sətirin ikinci və üçüncü simvolları olan \"el\" ekrana çap edilir.\r\n\r\n```go\r\nfor i, r := range \"hello\" {\r\n    fmt.Printf(\"%d: %s\\n\", i, string(r))\r\n}\r\n```\r\n\r\nBu nümunədə, for döngüsü istifadə edilərək range funksiyası ilə \"hello\" stringindəki hər bir simvola giriş edilir. Hər simvolun mövqeyi və dəyəri ekrana çap olunur. Runes, Go proqramlaşdırma dilində, bir Unicode simvolunun birləşməsini ifadə edən bir məlumat tipidir. Runes, 1-4 bayt arasında dəyişən ölçülərdə ola bilən simvolları təmsil etmək üçün istifadə olunur.\r\n\r\n```go\r\nstr := \"こんにちは\"\r\nfor i, r := range str {\r\n    fmt.Printf(\"%d: %c\\n\", i, r)\r\n}\r\n```\r\n\r\nBu nümunədə, str adlı bir string dəyişəni təyin edilir və \"こんにちは\" dəyəri verilir. for döngüsü istifadə edilərək range funksiyası ilə hər bir simvola giriş edilir və simvolun mövqeyi və dəyəri ekrana çap olunur.\r\n\r\n## Structs\r\n\r\nStructlar, Go proqramlaşdırma dilində, fərqli məlumat tiplərini özündə birləşdirən bir məlumat quruluşudur. Bu quruluşda, müxtəlif məlumat tiplərinə sahib məlumatları bir arada saxlaya və bu məlumatlar üzərində əməliyyatlar apara bilərsiniz.\r\n\r\n```go\r\ntype Person struct {\r\n    Name string\r\n    Age  int\r\n}\r\n\r\nvar p Person\r\np.Name = \"John Doe\"\r\np.Age = 42\r\nfmt.Println(p)\r\nfmt.Printf(\"Name: %s, Age: %d\\n\", p.Name, p.Age)\r\n```\r\n\r\nBu nümunədə, Person adlı bir struct yaradılır və Name adlı bir string tipində və Age adlı bir int tipində iki xüsusiyyət təyin edilir. var açar sözü ilə p adlı bir Person tipində dəyişən təyin edilir. p dəyişəninin Name və Age xüsusiyyətləri, p.Name və p.Age ifadələri istifadə edilərək təyin edilir və fmt.Println() funksiyası ilə p dəyişəni ekrana çap edilir. Əlavə olaraq, p.Name və p.Age ifadələri ilə, Name və Age xüsusiyyətləri ayrıca ekrana çap edilir.\r\n\r\n```go\r\ntype Rectangle struct {\r\n    width  float64\r\n    height float64\r\n}\r\n\r\nfunc (r Rectangle) area() float64 {\r\n    return r.width * r.height\r\n}\r\n\r\nr := Rectangle{width: 3.0, height: 4.0}\r\nfmt.Println(r.area())\r\n```\r\n\r\nBu nümunədə, Rectangle adlı bir struct yaradılır və width adlı bir float64 tipində və height adlı bir float64 tipində iki xüsusiyyət təyin edilir. area adlı bir funksiya, Rectangle tipində bir parametr qəbul edir və düzbucaqlının sahəsini hesablayır. Funksiyanın qaytardığı nəticə düzbucaqlının sahəsidir. r adlı bir Rectangle dəyişəni yaradılır və width və height xüsusiyyətlərinə 3.0 və 4.0 dəyərləri verilir. r.area() ifadəsi istifadə edilərək, düzbucaqlının sahəsi hesablanır və nəticə ekrana çap edilir.\r\n\r\n## Methods\r\n\r\nMetodlar, Go proqramlaşdırma dilində, bir məlumat quruluşuna məxsus əməliyyatları yerinə yetirmək üçün istifadə edilən funksiya növüdür. Bu əməliyyatlar, məlumat quruluşunun xüsusiyyətləri üzərində işləyərək nəticə yaradır.\r\n\r\n```go\r\ntype Rectangle struct {\r\n    width  float64\r\n    height float64\r\n}\r\n\r\nfunc (r Rectangle) area() float64 {\r\n    return r.width * r.height\r\n}\r\n\r\nfunc (r Rectangle) perimeter() float64 {\r\n    return 2 * (r.width + r.height)\r\n}\r\n\r\nr := Rectangle{width: 3.0, height: 4.0}\r\nfmt.Println(r.area())\r\nfmt.Println(r.perimeter())\r\n```\r\n\r\nBu nümunədə, Rectangle adlı bir struct yaradılır və width adlı bir float64 tipində və height adlı bir float64 tipində iki xüsusiyyət təyin olunur. area adlı funksiya, Rectangle tipində parametr qəbul edir və düzbucaqlının sahəsini hesablayır. Funksiyanın qaytardığı nəticə, düzbucaqlının sahəsidir. perimeter adlı funksiya da Rectangle tipində parametr alır və düzbucaqlının perimetrini hesablayır. Funksiyanın qaytardığı nəticə, düzbucaqlının perimetridir. r adlı bir Rectangle dəyişəni yaradılır və width və height xüsusiyyətlərinə 3.0 və 4.0 dəyərləri təyin olunur. r.area() və r.perimeter() ifadələrindən istifadə edərək düzbucaqlının sahəsi və perimetri hesablanır və nəticələr ekrana yazdırılır.\r\n\r\n```go\r\ntype Person struct {\r\n    Name string\r\n    Age  int\r\n}\r\n\r\nfunc (p *Person) setName(name string) {\r\n    p.Name = name\r\n}\r\n\r\nfunc (p *Person) setAge(age int) {\r\n    p.Age = age\r\n}\r\n\r\nfunc (p Person) getName() string {\r\n    return p.Name\r\n}\r\n\r\nfunc (p Person) getAge() int {\r\n    return p.Age\r\n}\r\n\r\np := Person{Name: \"John Doe\", Age: 42}\r\np.setName(\"Jane Doe\")\r\np.setAge(35)\r\nfmt.Printf(\"Name: %s, Age: %d\\n\", p.getName(), p.getAge())\r\n```\r\n\r\nBu nümunədə, Person adlı bir struct yaradılır və Name adlı bir string tipində və Age adlı bir int tipində iki xüsusiyyət təyin olunur. setName adlı funksiya, Person tipində pointer (\\*Person) parametr qəbul edir və şəxsin adını dəyişir. setAge adlı funksiya, Person tipində pointer (\\*Person) parametr qəbul edir və şəxsin yaşını dəyişir. getName adlı funksiya, Person tipində parametr qəbul edir və şəxsin adını qaytarır. getAge adlı funksiya isə şəxsin yaşını qaytarır. p adlı bir Person dəyişəni yaradılır və Name və Age xüsusiyyətlərinə \"John Doe\" və 42 dəyərləri təyin olunur. Daha sonra, p.setName(\"Jane Doe\") və p.setAge(35) ifadələrindən istifadə edərək şəxsin adı və yaşı dəyişdirilir.\r\n\r\n## Interfaces\r\n\r\nGo dilində interfeys, bir və ya bir neçə metodun müəyyən imza dəstini təyin edən bir məlumat tipidir. Bu imza dəsti, bir məlumat tipinin hansı metodları tətbiq etməli olduğunu göstərir. Bu səbəbdən, interfeyslər, bir məlumat tipinin hansı xüsusiyyətlərə malik olduğunu təyin etmək üçün istifadə olunur.\r\n\r\nMəsələn, bir fiqurun sahəsini hesablamaq üçün area adlı bir funksiya təyin etdiyinizi düşünün. Kvadrat, dairə və düzbucaqlı kimi müxtəlif fiqurlar area funksiyasını fərqli şəkildə tətbiq edirlər. Bu halda, hər bir fiqurun sahəsini hesablamaq üçün ayrı-ayrı funksiyalar təyin etmək əvəzinə, interfeys istifadə edərək hamısını eyni tipdə bir məlumatda toplaya bilərsiniz.\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"math\"\r\n)\r\n\r\ntype Shape interface {\r\n\tarea() float64\r\n}\r\n\r\ntype Circle struct {\r\n\tradius float64\r\n}\r\n\r\ntype Rectangle struct {\r\n\twidth, height float64\r\n}\r\n\r\ntype Square struct {\r\n\tside float64\r\n}\r\n\r\nfunc (c Circle) area() float64 {\r\n\treturn math.Pi * c.radius * c.radius\r\n}\r\n\r\nfunc (r Rectangle) area() float64 {\r\n\treturn r.width * r.height\r\n}\r\n\r\nfunc (s Square) area() float64 {\r\n\treturn s.side * s.side\r\n}\r\n\r\nfunc getArea(shape Shape) float64 {\r\n\treturn shape.area()\r\n}\r\n\r\nfunc main() {\r\n\tcircle := Circle{radius: 5}\r\n\trectangle := Rectangle{width: 5, height: 10}\r\n\tsquare := Square{side: 5}\r\n\r\n\tfmt.Printf(\"Circle area: %f\\n\", getArea(circle))\r\n\tfmt.Printf(\"Rectangle area: %f\\n\", getArea(rectangle))\r\n\tfmt.Printf(\"Square area: %f\\n\", getArea(square))\r\n}\r\n```\r\n\r\nBu nümunədə, Shape adlı bir interfeys təyin olunur və area adlı bir funksiya imzası göstərilir. Circle, Rectangle və Square adlı üç fərqli struktura malik məlumat tipləri təyin olunur və hər biri area adlı funksiyanı həyata keçirir. getArea adlı bir funksiya təyin olunur və parametri Shape tipindədir. Bu funksiya, sahəsi hesablanacaq fiqur məlumatını alır və area funksiyasını çağıraraq fiqurun sahəsini hesablamağa imkan verir. main funksiyasında isə, nümunə olaraq circle, rectangle və square adlı üç fərqli dəyişən yaradılır. Bu dəyişənlərin hər biri getArea funksiyasına parametr olaraq verilir və hər bir fiqurun sahəsi hesablanaraq ekrana yazdırılır.\r\n\r\nOutput:\r\n\r\n```go\r\nCircle area: 78.539816\r\nRectangle area: 50.000000\r\nSquare area: 25.000000\r\n```\r\n\r\n## Struct Embedding\r\n\r\nGo dilində struct embedding, bir struct-ın başqa bir struct daxilində yerləşdirilməsi ilə digər struct-ın sahələrinə və metodlarına birbaşa giriş imkanı verir. Bu, təkcə kod təkrarını azaltmır, həm də kompozisiyanı təşviq edir, beləliklə, bir struct-ın başqa bir struct-a miras buraxmadan onun funksionallığını təmin etməyə imkan verir.\r\n\r\n```go\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\ntype Person struct {\r\n\tName string\r\n\tAge  int\r\n}\r\n\r\nfunc (p Person) SayHello() {\r\n\tfmt.Printf(\"Hello, my name is %s and I'm %d years old\\n\", p.Name, p.Age)\r\n}\r\n\r\ntype Employee struct {\r\n\tPerson\r\n\tCompany string\r\n}\r\n\r\nfunc main() {\r\n\temp := Employee{\r\n\t\tPerson: Person{\r\n\t\t\tName: \"John\",\r\n\t\t\tAge:  30,\r\n\t\t},\r\n\t\tCompany: \"ABC Inc.\",\r\n\t}\r\n\r\n\temp.SayHello()\r\n}\r\n```\r\n\r\nBu nümunədə, Person adlı bir struct təyin edilir və Name və Age adlı iki sahəsi var. Eyni zamanda SayHello adlı bir funksiyası mövcuddur.\r\n\r\nEmployee adlı bir struct təyin edilir və onun içərisində Person struct-ı yerləşdirilir. Employee-nin əlavə olaraq Company adlı bir sahəsi də var. main funksiyasında, emp adlı bir Employee dəyişəni yaradılır. Bu dəyişənin Person sahəsinə Person tipində bir dəyər atanır. SayHello funksiyası emp dəyişəni üzərindən çağırılır və nəticə ekrana yazdırılır.\r\n\r\nOutput:\r\n\r\n```go\r\nHello, my name is John and I'm 30 years old\r\n```\r\n\r\nBu nümunədə, Employee adlı struktur, Person strukturunu daxili olaraq yerləşdirir. Bu, Employee strukturuna Person-un bütün sahələrinə və funksiyalarına birbaşa çıxış imkanı verir. Beləliklə, Employee strukturunu istifadə edərək həm Employee, həm də Person məlumatlarına asanlıqla giriş əldə etmək mümkündür. Bu xüsusiyyət, kod təkrarını azaldır və strukturları daha modul halına gətirir.\r\n\r\n## Errors\r\n\r\nGo dilində səhv (error) idarəetməsi, error adlı bir məlumat tipi vasitəsilə həyata keçirilir. Bu tip, bir funksiyanın nəticəsi olaraq ya bir səhv mesajı, ya da nil dəyərini qaytarmaq üçün istifadə olunur. Bu, proqramın gözlənilməyən vəziyyətlərdə necə davranmalı olduğunu idarə etməyə kömək edir.\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc divide(x, y float64) (float64, error) {\r\n\tif y == 0 {\r\n\t\treturn 0, errors.New(\"Cannot divide by zero\")\r\n\t}\r\n\treturn x / y, nil\r\n}\r\n\r\nfunc main() {\r\n\tresult, err := divide(10, 2)\r\n\tif err != nil {\r\n\t\tfmt.Println(err)\r\n\t} else {\r\n\t\tfmt.Println(result)\r\n\t}\r\n\r\n\tresult, err = divide(10, 0)\r\n\tif err != nil {\r\n\t\tfmt.Println(err)\r\n\t} else {\r\n\t\tfmt.Println(result)\r\n\t}\r\n}\r\n```\r\n\r\nBu nümunədə, divide adlı bir funksiya təyin edilir və iki ədədi bölür. Lakin, əgər ikinci ədəd 0 olarsa, bir səhv qaytarır.\r\n\r\nmain funksiyasında, divide funksiyası iki fərqli parametr ilə çağırılır. err adlı bir səhv dəyişəni istifadə edilərək hər bir çağırışın nəticəsi yoxlanılır. Əgər səhv varsa, səhv mesajı ekrana yazdırılır. Əks halda, nəticə ekrana yazdırılır.\r\n\r\nOutput:\r\n\r\n```go\r\n5 <nil>\r\nCannot divide by zero\r\n```\r\n\r\nBu nümunədə divide funksiyası sıfıra bölmə vəziyyətini idarə etmək üçün səhv idarəetməsindən istifadə edir. Əgər y sıfır olarsa, errors.New ilə yaradılmış səhv qaytarılır. Proqram err dəyişəni ilə səhv olub-olmadığını yoxlayır və əgər səhv varsa, onu ekrana yazdırır. Bu yanaşma Go dilində səhv idarəetməsini daha etibarlı və idarə olunan edir.\r\n\r\n## Goroutines\r\n\r\nGo dilində goroutine-lər, eyni anda çalışan əməliyyatlardır. Goroutine-lər go açar sözü istifadə edilərək yaradılır və fərqli əməliyyatları eyni vaxtda həyata keçirmək üçün istifadə olunur.\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\nfunc sayHello() {\r\n\tfmt.Println(\"Hello\")\r\n}\r\n\r\nfunc main() {\r\n\tgo sayHello() // goroutine\r\n\ttime.Sleep(time.Second)\r\n\tfmt.Println(\"World\")\r\n}\r\n```\r\n\r\nBu nümunədə, sayHello adlı bir funksiya təyin edilir və \"Hello\" mesajını ekrana yazdırır.\r\n\r\nmain funksiyasında, sayHello funksiyası bir goroutine olaraq çağırılır. Bu səbəbdən, sayHello funksiyasının icrası digər əməliyyatlardan müstəqil olaraq baş verir. time.Sleep funksiyası bir saniyəlik gözləmə müddəti əlavə edir. Nəticədə, \"World\" mesajı ekrana yazdırılır.\r\n\r\nOutput:\r\n\r\n```go\r\nHello\r\nWorld\r\n```\r\n\r\nBu nümunədə, goroutine istifadə edərək sayHello funksiyası eyni anda çalışdırıldı. sayHello funksiyası goroutine olaraq çağırıldığı üçün digər əməliyyatlardan müstəqil işləd və nəticədə ekrana \"Hello\" mesajı yazdırıldıktan sonra \"World\" mesajı yazdırıldı.\r\n\r\n## Channel\r\n\r\nGo dilində kanal (channel), goroutine-lər arasında məlumat ötürmək üçün istifadə olunan bir məlumat strukturudur. Kanal, make açar sözü ilə yaradılır və <- operatoru ilə məlumat göndərmə və qəbul etmə əməliyyatları həyata keçirilir.\r\n\r\n```go\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\tmessages := make(chan string)\r\n\r\n\tgo func() { messages <- \"Hello\" }()\r\n\r\n\tmsg := <-messages\r\n\tfmt.Println(msg)\r\n}\r\n```\r\n\r\nBu nümunədə, messages adlı bir kanal yaradılır.\r\n\r\ngo açar sözü ilə bir goroutine yaradılır və bu goroutine messages kanalına \"Hello\" mesajını göndərir.\r\n\r\nmain funksiyasında, msg adlı bir dəyişkənə messages kanalından bir mesaj alınır və ekrana yazdırılır.\r\n\r\nOutput:\r\n\r\n```go\r\nHello\r\n```\r\n\r\nBu örnekte, channel kullanarak, bir goroutine'dan ana iş parçacığına bir mesaj gönderildi. Bu nedenle, goroutine işlemi tamamlandıktan sonra ana iş parçacığı channel'dan mesajı alır ve sonucu ekrana yazdırır.\r\n\r\nKanallar, Golang'de birçok durumda kullanılabilir, örneğin:\r\n\r\nBu nümunədə, kanal istifadə edərək bir goroutine-dən ana iş parçacığına bir mesaj göndərildi. Bu səbəbdən, goroutine tamamlandıqdan sonra ana iş parçacığı kanaldan mesajı alır və nəticəni ekrana yazdırır.\r\n\r\nKanallar Go dilində bir çox vəziyyətdə istifadə oluna bilər, məsələn:\r\n\r\n1. Goroutine-lər arasında məlumat mübadiləsi üçün\r\n2. Sinxronizasiya əməliyyatları üçün\r\n3. Tətbiqinizin performansını artırmaq üçün (paralel emal etmək)\r\n4. Goroutine-lər arasında məlumat yarışlarını qarşısını almaq üçün\r\n5. Tapşırıqların koordinasiyası və sinxronizasiyası üçün\r\n\r\n\r\n## Select\r\n\r\nGo dilində, select açar sözü bir neçə kanalı `(channel)` dinləyərək hansı kanalın mesaj göndərdiyini müəyyənləşdirə bilər. Bu xüsusiyyət kanalların sinxronizasiyasını asanlaşdırır və fərqli goroutin-lər arasında mesajlaşmanı idarə edir.\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\nfunc main() {\r\n\tc1 := make(chan string)\r\n\tc2 := make(chan string)\r\n\r\n\tgo func() {\r\n\t\ttime.Sleep(time.Second * 1)\r\n\t\tc1 <- \"one\"\r\n\t}()\r\n\r\n\tgo func() {\r\n\t\ttime.Sleep(time.Second * 2)\r\n\t\tc2 <- \"two\"\r\n\t}()\r\n\r\n\tfor i := 0; i < 2; i++ {\r\n\t\tselect {\r\n\t\tcase msg1 := <-c1:\r\n\t\t\tfmt.Println(\"received\", msg1)\r\n\t\tcase msg2 := <-c2:\r\n\t\t\tfmt.Println(\"received\", msg2)\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nBu nümunədə, `c1` və `c2` adlı iki kanal yaradılır və mesaj göndərmə prosesi üçün goroutin-lər yaradılır.\r\n\r\nmain funksiyasında, select açar sözü istifadə edilərək, c1 və c2 kanalları dinlənilir. İlk olaraq, goroutin-lər arasındakı gözləmə müddətinə görə, `c1` kanalından bir mesaj alınır və ekrana yazdırılır. Daha sonra, `c2` kanalından bir mesaj alınır və ekrana yazdırılır.\r\n\r\nOutput:\r\n\r\n```golang\r\nreceived one\r\nreceived two\r\n```\r\n\r\nBu nümunədə, select açar sözü istifadə edilərək, `c1`  və `c2` kanallarını dinləyən bir for döngüsü yaradıldı. Bu, mesaj alım müddətinə əsaslanaraq fərqli kanalların dinlənilməsinə imkan verir. Nəticədə, goroutin-lər arasındakı mesajlaşma müəyyən bir qaydada həyata keçirilir və select açar sözü istifadə edilərək sinxronizasiya təmin edilir.\r\n\r\n\r\n## Timeouts\r\n\r\nGo dilində, timeout əməliyyatları, xüsusilə şəbəkə əməliyyatları zamanı vacibdir. `time` paketindən istifadə edərək, müəyyən bir müddət gözləmək mümkündür. Əgər müddət aşılırsa, timeout xətası baş verir.\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\nfunc main() {\r\n\tc1 := make(chan string, 1)\r\n\r\n\tgo func() {\r\n\t\ttime.Sleep(time.Second * 2)\r\n\t\tc1 <- \"result 1\"\r\n\t}()\r\n\r\n\tselect {\r\n\tcase res := <-c1:\r\n\t\tfmt.Println(res)\r\n\tcase <-time.After(time.Second * 1):\r\n\t\tfmt.Println(\"timeout 1\")\r\n\t}\r\n\r\n\tc2 := make(chan string, 1)\r\n\r\n\tgo func() {\r\n\t\ttime.Sleep(time.Second * 2)\r\n\t\tc2 <- \"result 2\"\r\n\t}()\r\n\r\n\tselect {\r\n\tcase res := <-c2:\r\n\t\tfmt.Println(res)\r\n\tcase <-time.After(time.Second * 3):\r\n\t\tfmt.Println(\"timeout 2\")\r\n\t}\r\n}\r\n```\r\n\r\nBu nümunədə `c1` və `c2` adlı iki kanal yaradılır və mesaj göndərmə əməliyyatları üçün goroutine-lər istifadə olunur. İlk olaraq, `select` açar sözü istifadə edərək, `c1` kanalından bir mesaj gözlənilir. Amma `time.After` ilə bir saniyə vaxt limiti təyin edilir. Əgər bu vaxt aşılırsa, \"timeout 1\" mesajı çap olunur.\r\n\r\nSonra, eyni əməliyyat `c2` kanalı üçün edilir və bu dəfə 3 saniyə gözlənilir.\r\n\r\n**Output**:\r\n\r\n```go\r\ntimeout 1\r\nresult 2\r\n```\r\n\r\n***\r\n\r\n## Non-Blocking Channel Operations\r\n\r\nGo dilində, kanallar adətən bloklama xüsusiyyətinə malikdir. Yəni, bir goroutine bir kanala mesaj göndərmək və ya mesaj almaq istəyirsə, həmin əməliyyat tamamlanana qədər dayanar. Lakin, `select` açar sözü istifadə edilərək, non-blocking əməliyyatlar da həyata keçirmək mümkündür.\r\n\r\n```go\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\tmessages := make(chan string)\r\n\tsignals := make(chan bool)\r\n\r\n\tselect {\r\n\tcase msg := <-messages:\r\n\t\tfmt.Println(\"received message\", msg)\r\n\tdefault:\r\n\t\tfmt.Println(\"no message received\")\r\n\t}\r\n\r\n\tmsg := \"hello\"\r\n\tselect {\r\n\tcase messages <- msg:\r\n\t\tfmt.Println(\"sent message\", msg)\r\n\tdefault:\r\n\t\tfmt.Println(\"no message sent\")\r\n\t}\r\n\r\n\tselect {\r\n\tcase msg := <-messages:\r\n\t\tfmt.Println(\"received message\", msg)\r\n\tdefault:\r\n\t\tfmt.Println(\"no message received\")\r\n\t}\r\n\r\n\tselect {\r\n\tcase sig := <-signals:\r\n\t\tfmt.Println(\"received signal\", sig)\r\n\tdefault:\r\n\t\tfmt.Println(\"no signal received\")\r\n\t}\r\n\r\n\tsignal := true\r\n\tselect {\r\n\tcase signals <- signal:\r\n\t\tfmt.Println(\"sent signal\", signal)\r\n\tdefault:\r\n\t\tfmt.Println(\"no signal sent\")\r\n\t}\r\n\r\n\tselect {\r\n\tcase sig := <-signals:\r\n\t\tfmt.Println(\"received signal\", sig)\r\n\tdefault:\r\n\t\tfmt.Println(\"no signal received\")\r\n\t}\r\n}\r\n```\r\n\r\nBu nümunədə, `messages` adlı bir kanal yaradılır və göndərilməmiş mesajın yoxlanılması üçün `select` istifadə edilir. Ardından, bir mesaj yaradılır və kanala göndərilməyə çalışılır. Əgər kanal boşdursa, \"no message sent\" çap olunur.\r\n\r\n**Output**:\r\n\r\n```go\r\nno message received\r\nsent message hello\r\nno message received\r\nno signal received\r\nsent signal true\r\nreceived signal true\r\n```\r\n\r\n***\r\n\r\n## Closing Channels\r\n\r\nGo dilində, kanalların bağlanması, mesajların göndərilməsi və alınması arasında sinxronizasiya yaradır. `close` funksiyası ilə bir kanal bağlana bilər. Bağlanan kanala daha artıq mesaj göndərilə bilməz və bu kanaldan mesajlar alınmaz.\r\n\r\n```go\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\tjobs := make(chan int, 5)\r\n\tdone := make(chan bool)\r\n\r\n\tgo func() {\r\n\t\tfor {\r\n\t\t\tj, more := <-jobs\r\n\t\t\tif more {\r\n\t\t\t\tfmt.Println(\"received job\", j)\r\n\t\t\t} else {\r\n\t\t\t\tfmt.Println(\"received all jobs\")\r\n\t\t\t\tdone <- true\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t}()\r\n\r\n\tfor j := 1; j <= 3; j++ {\r\n\t\tjobs <- j\r\n\t\tfmt.Println(\"sent job\", j)\r\n\t}\r\n\r\n\tclose(jobs)\r\n\tfmt.Println(\"sent all jobs\")\r\n\r\n\t<-done\r\n}\r\n```\r\n\r\nBu nümunədə `jobs` adlı bir kanal yaradılır və goroutine bu kanaldan mesajlar qəbul edir. `close` funksiyası ilə kanal bağlanır və bütün işlərin tamamlandığı siqnalı `done` kanalına göndərilir.\r\n\r\n**Output**:\r\n\r\n```go\r\nsent job 1\r\nsent job 2\r\nsent job 3\r\nsent all jobs\r\nreceived job 1\r\nreceived job 2\r\nreceived job 3\r\nreceived all jobs\r\n```\r\n\r\n\r\n\r\n***\r\n\r\n## Range over Channels\r\n\r\nGo-da `range` açar sözü istifadə edərək kanaldan mesajlar almaq mümkündür. Bu zaman kanal açıq qaldığı müddətdə mesajlar qəbul edilir. Kanal bağlandıqda isə `range` döngüsü dayanır.\r\n\r\n```go\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\tqueue := make(chan string, 2)\r\n\tqueue <- \"one\"\r\n\tqueue <- \"two\"\r\n\tclose(queue)\r\n\r\n\tfor elem := range queue {\r\n\t\tfmt.Println(elem)\r\n\t}\r\n}\r\n```\r\n\r\nBu nümunədə, `queue` adlı bir kanal yaradılır və iki mesaj kanala yerləşdirilir. Kanal bağlandıqdan sonra, `range` döngüsü ilə kanalın bütün elementləri çap edilir.\r\n\r\n**Output**:\r\n\r\n```\r\none\r\ntwo\r\n```\r\n\r\n***\r\n\r\n## Timers\r\n\r\nGo dilində `time` paketindən istifadə edərək timerlər yaratmaq mümkündür. Timerlər müəyyən bir müddətdən sonra bir siqnal göndərir. `time.NewTimer` funksiyası müəyyən edilmiş vaxtdan sonra bir siqnal göndərən bir timer yaradır.\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\nfunc main() {\r\n\ttimer1 := time.NewTimer(time.Second * 2)\r\n\r\n\t<-timer1.C\r\n\tfmt.Println(\"Timer 1 fired\")\r\n\r\n\ttimer2 := time.NewTimer(time.Second)\r\n\tgo func() {\r\n\t\t<-timer2.C\r\n\t\tfmt.Println(\"Timer 2 fired\")\r\n\t}()\r\n\r\n\tstop2 := timer2.Stop()\r\n\tif stop2 {\r\n\t\tfmt.Println(\"Timer 2 stopped\")\r\n\t}\r\n\r\n\ttime.Sleep(time.Second * 2)\r\n}\r\n```\r\n\r\nBu nümunədə, iki timer yaradılır. Birincisi 2 saniyə sonra işə düşür və \"Timer 1 fired\" çap edir. İkincisi isə 1 saniyə sonra işə düşmədən dayandırılır, buna görə də \"Timer 2 stopped\" çap olunur.\r\n\r\n**Output**:\r\n\r\n```go\r\nTimer 1 fired\r\nTimer 2 stopped\r\n```\r\n\r\n***\r\n\r\n## Tickers\r\n\r\nGo-da `Ticker` periodik olaraq müəyyən bir intervalla siqnal göndərən bir mexanizmdir. `time.NewTicker` funksiyası ilə ticker yaradılır və hər dəfə təyin edilmiş intervalla siqnallar alır.\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\nfunc main() {\r\n\tticker := time.NewTicker(time.Millisecond * 500)\r\n\tdone := make(chan bool)\r\n\r\n\tgo func() {\r\n\t\tfor {\r\n\t\t\tselect {\r\n\t\t\tcase <-done:\r\n\t\t\t\treturn\r\n\t\t\tcase t := <-ticker.C:\r\n\t\t\t\tfmt.Println(\"Tick at\", t)\r\n\t\t\t}\r\n\t\t}\r\n\t}()\r\n\r\n\ttime.Sleep(time.Millisecond * 1600)\r\n\tticker.Stop()\r\n\tdone <- true\r\n\tfmt.Println(\"Ticker stopped\")\r\n}\r\n```\r\n\r\nBu nümunədə `ticker` hər 500 millisekundda bir \"tick\" siqnalı göndərir və bu siqnallar çap edilir. `time.Sleep` ilə müəyyən müddətdən sonra ticker dayandırılır və proqram sonlanır.\r\n\r\n**Output**:\r\n\r\n```go\r\nTick at 2023-09-10 12:34:56.123456789 +0000 UTC m=+0.500123456\r\nTick at 2023-09-10 12:34:56.623456789 +0000 UTC m=+1.000123456\r\nTick at 2023-09-10 12:34:57.123456789 +0000 UTC m=+1.500123456\r\nTicker stopped\r\n```\r\n\r\n***\r\n\r\n## Worker Pools\r\n\r\nWorker pool-ları Go-da paralel hesablama üçün istifadə olunur. Bir neçə goroutine bir-birindən müstəqil işləri eyni zamanda yerinə yetirə bilər. Bu şəkildə bir neçə işçinin bir pool-da işləməsi təşkil edilə bilər.\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\nfunc worker(id int, jobs <-chan int, results chan<- int) {\r\n\tfor j := range jobs {\r\n\t\tfmt.Println(\"worker\", id, \"started  job\", j)\r\n\t\ttime.Sleep(time.Second)\r\n\t\tfmt.Println(\"worker\", id, \"finished job\", j)\r\n\t\tresults <- j * 2\r\n\t}\r\n}\r\n\r\nfunc main() {\r\n\tconst numJobs = 5\r\n\tjobs := make(chan int, numJobs)\r\n\tresults := make(chan int, numJobs)\r\n\r\n\tfor w := 1; w <= 3; w++ {\r\n\t\tgo worker(w, jobs, results)\r\n\t}\r\n\r\n\tfor j := 1; j <= numJobs; j++ {\r\n\t\tjobs <- j\r\n\t}\r\n\tclose(jobs)\r\n\r\n\tfor a := 1; a <= numJobs; a++ {\r\n\t\t<-results\r\n\t}\r\n}\r\n```\r\n\r\nBu nümunədə 3 işçi yaradılır və 5 iş onları icra etməsi üçün göndərilir. Hər işçinin hansı işi icra etməyə başladığı və tamamladığı çap olunur.\r\n\r\n**Output**:\r\n\r\n```go\r\nworker 1 started  job 1\r\nworker 2 started  job 2\r\nworker 3 started  job 3\r\nworker 1 finished job 1\r\nworker 1 started  job 4\r\nworker 2 finished job 2\r\nworker 2 started  job 5\r\nworker 3 finished job 3\r\nworker 1 finished job 4\r\nworker 2 finished job 5\r\n```\r\n\r\n\r\n\r\n## WaitGroups\r\n\r\nWaitGroup quruluşu Go dilində goroutinlər arasında sinxronizasiya təmin etmək üçün istifadə edilən bir mexanizmdir. WaitGroup quruluşu Go-nun `sync` paketində yerləşir.\r\n\r\nWaitGroup proqramçılara işləyəcək funksiyaların sayını əvvəlcədən müəyyən etməyə və həmin funksiyaların tamamlanmasını gözləməyə imkan verir. Hər goroutine işləmə bitdikdə, WaitGroup quruluşundakı `Done()` funksiyasını çağırır. WaitGroup-dakı `Wait()` funksiyası isə bütün funksiyaların tamamlanmasını gözləyir.\r\n\r\nAşağıdakı nümunə, WaitGroup quruluşunun istifadəsini göstərir:\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n    \"sync\"\r\n    \"time\"\r\n)\r\n\r\nfunc worker(id int, wg *sync.WaitGroup) {\r\n    defer wg.Done()\r\n\r\n    fmt.Printf(\"Worker %d starting\\n\", id)\r\n    time.Sleep(time.Second)\r\n    fmt.Printf(\"Worker %d done\\n\", id)\r\n}\r\n\r\nfunc main() {\r\n    var wg sync.WaitGroup\r\n\r\n    for i := 1; i <= 5; i++ {\r\n        wg.Add(1)\r\n        go worker(i, &wg)\r\n    }\r\n\r\n    wg.Wait()\r\n\r\n    fmt.Println(\"All workers done\")\r\n}\r\n```\r\n\r\nBu nümunədə, 5 işçi funksiyası `worker()` funksiyası çağırılır. WaitGroup quruluşu, hər işçi funksiyası başlamazdan əvvəl `Add()` funksiyası ilə gözlənilən işlərin sayını artırır. Hər işçi funksiyası tamamlandıqda, `Done()` funksiyası ilə bir işin başa çatdığı bildirilir. `Wait()` funksiyası isə bütün işlərin bitməsini gözləmək üçün istifadə olunur. Nəticədə, bütün işçi funksiyaları bitdikdən sonra `main()` funksiyası \"All workers done\" mesajını çap edir.\r\n\r\n**Ouput**:\r\n\r\n```go\r\n\r\nWorker 5 starting\r\nWorker 3 starting\r\nWorker 4 starting\r\nWorker 1 starting\r\nWorker 2 starting\r\nWorker 5 done\r\nWorker 3 done\r\nWorker 2 done\r\nWorker 1 done\r\nWorker 4 done\r\nAll workers done\r\n```\r\n\r\n\r\n## Rate Limiting\r\n\r\nRate Limiting, bir API və ya xidmətin istifadəçinin müəyyən bir zaman ərzində edə biləcəyi sorğu sayını məhdudlaşdırmaq üçün istifadə edilən bir metoddur. Bu metod, tətbiqin və ya xidmətin həddindən artıq yüklənməsinin qarşısını almaq üçün istifadə oluna bilər.\r\n\r\nGo dilində, Rate Limiting etmək üçün `time` paketi istifadə oluna bilər. Bu paket, müəyyən bir zaman çərçivəsində müəyyən bir əməliyyatın yerinə yetirilməsi üçün nə qədər gözləmək lazım olduğunu hesablamaq üçün istifadə edilir.\r\n\r\nAşağıdakı nümunədə, `time.Ticker` və `time.Sleep` istifadə edilərək Rate Limiting nümunəsi göstərilir:\r\n\r\n```golang\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n    \"time\"\r\n)\r\n\r\nfunc main() {\r\n    requests := make(chan int, 5)\r\n\r\n    for i := 1; i <= 5; i++ {\r\n        requests <- i\r\n    }\r\n    close(requests)\r\n\r\n    limiter := time.Tick(200 * time.Millisecond)\r\n\r\n    for req := range requests {\r\n        <-limiter\r\n        fmt.Println(\"request\", req, time.Now())\r\n    }\r\n}\r\n```\r\n\r\nBu nümunədə, `requests` adlı bir kanal yaradılır və içinə 5 sorğu əlavə edilir. Daha sonra `limiter` adlı bir `time.Ticker` yaradılır və 200 millisaniyəlik bir müddətlə məhdudlaşdırılır.\r\n\r\nDaha sonra, `requests` kanalındakı hər bir sorğu məhdudlaşdırıcıya uyğun olaraq işlədir. Hər sorğu arasında 200 millisaniyəlik fasilə ilə işlənməsi təmin edilir.\r\n\r\n```\r\nrequest 1 2023-05-23 15:56:01.46705 +0300 +03 m=+0.201167209\r\nrequest 2 2023-05-23 15:56:01.667008 +0300 +03 m=+0.401132584\r\nrequest 3 2023-05-23 15:56:01.867014 +0300 +03 m=+0.601146918\r\nrequest 4 2023-05-23 15:56:02.067052 +0300 +03 m=+0.801193043\r\nrequest 5 2023-05-23 15:56:02.267025 +0300 +03 m=+1.001173793\r\n```\r\n\r\nBu şəkildə, Rate Limiting istifadə edərək sorğular müəyyən bir sürətlə işlənir.
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
--- a/README.md	(revision 014a5ae3d322f76f36bc66125a91f9218822eb4d)
+++ b/README.md	(date 1726112868948)
@@ -1378,49 +1378,3 @@
 ```
 
 
-## Rate Limiting
-
-Rate Limiting, bir API və ya xidmətin istifadəçinin müəyyən bir zaman ərzində edə biləcəyi sorğu sayını məhdudlaşdırmaq üçün istifadə edilən bir metoddur. Bu metod, tətbiqin və ya xidmətin həddindən artıq yüklənməsinin qarşısını almaq üçün istifadə oluna bilər.
-
-Go dilində, Rate Limiting etmək üçün `time` paketi istifadə oluna bilər. Bu paket, müəyyən bir zaman çərçivəsində müəyyən bir əməliyyatın yerinə yetirilməsi üçün nə qədər gözləmək lazım olduğunu hesablamaq üçün istifadə edilir.
-
-Aşağıdakı nümunədə, `time.Ticker` və `time.Sleep` istifadə edilərək Rate Limiting nümunəsi göstərilir:
-
-```golang
-package main
-
-import (
-    "fmt"
-    "time"
-)
-
-func main() {
-    requests := make(chan int, 5)
-
-    for i := 1; i <= 5; i++ {
-        requests <- i
-    }
-    close(requests)
-
-    limiter := time.Tick(200 * time.Millisecond)
-
-    for req := range requests {
-        <-limiter
-        fmt.Println("request", req, time.Now())
-    }
-}
-```
-
-Bu nümunədə, `requests` adlı bir kanal yaradılır və içinə 5 sorğu əlavə edilir. Daha sonra `limiter` adlı bir `time.Ticker` yaradılır və 200 millisaniyəlik bir müddətlə məhdudlaşdırılır.
-
-Daha sonra, `requests` kanalındakı hər bir sorğu məhdudlaşdırıcıya uyğun olaraq işlədir. Hər sorğu arasında 200 millisaniyəlik fasilə ilə işlənməsi təmin edilir.
-
-```
-request 1 2023-05-23 15:56:01.46705 +0300 +03 m=+0.201167209
-request 2 2023-05-23 15:56:01.667008 +0300 +03 m=+0.401132584
-request 3 2023-05-23 15:56:01.867014 +0300 +03 m=+0.601146918
-request 4 2023-05-23 15:56:02.067052 +0300 +03 m=+0.801193043
-request 5 2023-05-23 15:56:02.267025 +0300 +03 m=+1.001173793
-```
-
-Bu şəkildə, Rate Limiting istifadə edərək sorğular müəyyən bir sürətlə işlənir.
\ No newline at end of file
